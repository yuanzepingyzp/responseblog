{
  "项目总结之DRY":{
     "articletitle":"项目总结之DRY",
     "articlecontent":"<p>DRY既dont repeat yourself，是编程的一大原则，巧用这一原则可以为我们减少代码量提升编程的乐趣。毕竟世界上再也没有比不断的重复同一件事更无聊的事了</p><p>说到这里就使我想起一段实习的趣事，当初身为菜鸟中的菜鸟的我进入了电信某外包公司实习，更不要说我还是一个非科班的小菜鸡了，所以接到的第一个任务是能让人吐血的任务，手动格式化。就是去掉一段代码中间的无数个空格......</p><p>如果我按照要求的改了，不仅重复无聊对自身技术提升更没有啥帮助，还会助长自己的惰性，养成不求甚解的坏习惯，所以我果断决定自己重新做一个，虽然有点风险，但是其实我对技术实现了然于胸了，而且马克思曾经说过人与动物的根本区别在于人的主观能动性，并且高风险意味的高利润</p><p>最终我用自己的方式实现了项目需求，而正是的这次经历使我对js及ajax有了更深入的认识</p><p>说了这么多废话其实想告诉大家，在编程的DRY原则的总要信，他可以使你在编程时避免无聊的重复，避免对编程产生厌烦心理，获得更大的成就感，也使程序更优雅，一举三得何乐而不为呢<p>项目是这样得很简单在一个页面得绘制多个图表，如果按照以前得思维习惯是这么写得function chart1(){};function chart2(){}.....呵呵是不是很无聊？而这些图表长的大同小易所以很容易想到为什么不直接定义一个函数然后将他们不同得参数抽离出来作为形参分别传入呢，例如function draw(a,b.c..){},分别调用draw(a1,b1,c1),draw(a2,b2,c2)...就能用一个函数同时绘制多个图表了</p>",
     "date":"2016/10/27"
  },
  "项目总结之哈希表":{
    "articletitle":"项目总结之哈希表",
    "articlecontent":"<p>在项目中经常会遇到这样的情况，很多时候后台传个我们的数据与我们需要展示的数据是不一样的，比如后台传给我们的可能是BEIJING,SHANGHUAI,GUANGDONG.....这样的拼音，而我们需要的是与之对应的中文北京，上海，广东。</p><p>这种情况下我们最容易想到的是使用switch语句将拼音转为中文，既定义一个函数function returnchinese(english){switch(english){ case BEIJING:return '北京';}}，然后只需调用returnchinese('BEIJING');就可以了</p><p>那么还有没有更优雅一点的姿势呢？答案是肯定的。就是使用下面要介绍的哈希表了，同样的功能我们先定义一张map如var map={BEIJING:'北京',SHANGHUAI:'上海'....}，然后再定义一个函数function hash(english){return map[english]}，然后调用hash('BEIJING')；就能获得对应的中文名了。怎么样是不是优雅多了？使用hash表的好处远不止此，想象一下因为要实现某一功能你需要将视图中显示的数据发给后台接口请求对应的数据，而此时视图中的数据都是是中文的而后台只接受对应的英文该怎么做呢？，当然你同样可以使用switch实现转换，但这样的话你又重复了前面的代码，违反了DRY原则。但是如果你一开始就是使用的哈希表实现的话，此时只需要写一个逆向取值的函数function reversemap(chinese){for(i in map){if(map[i]==chinese){return i;}}}就可以了，是不是比那个重复的方案更加好看优雅呢？</p>",
    "date":"2016/10/27"
  },
  "项目总结之不定高度动画":{
    "articletitle":"项目总结之不定高度动画",
    "articlecontent":"<p>自从CSS3动画诞生以来，我便很少用纯JS来实现页面中的动画效果了，简单的动画主要用css伪类加transition和keyframes实现，稍微复杂的通过定义一个包含动画的类，然后用JS为元素增加移除类实现。</p><p>但是在实际的项目中会遇到这样一种情况，就是要添加动画的元素的高度是不固定的，也就是height:auto;那么这种情况下应该如何实现高度的transition动画</p><p>很容易想到的解决方案是利用js动画替代，但这不但实现起来麻烦还会带来性能上的问题，对于我这种信奉极简的人来说显然不是最优解。第二种方式是css动画+js只不过此时js仅用来获取元素的高度emlement.offsetHeight;还是麻烦..</p><p>第三种解决方案，将动画加在max-height属性，简单吧，原理等我想明白了在写</p>"
  },
  "项目总结之响应式设计":{
    "articletitle":"项目总结之响应式设计",
    "articlecontent":"<p>当我第一次听说响应式网页时，我试图猜测这是一种什么样的网站设计，于是我根据以往的“经验”，将他简单粗暴的定义为“使用百分比布局的网页”，到后来才知道这是自适应而非响应式。再后来学习了CSS3的媒体查询后，我再次简单粗暴的将他定义为“使用百分比加媒体查询实现的布局方式”。再后来又了解到了rem这个单位，又了解到了响应式布局的令一种思路</p><p>下面我想简述一下这种方案的实现思路，在此之前让我们认识一下什么是rem，解释一个缩写的最佳方式是还原出他的全称，rem意为root em，顾名思义这是一个相对与root的相对单位，而这个root就是DOM中的html元素，而且他相对的是html元素的font-size属性，举个例子，假设html{font-size：10px}，div{height：2rem}那么此时div的高度为20px。</p><p>那么怎样使用rem实现响应式布局呢，这里还得介绍一下CSS3的媒体查询，媒体查询的作用简单说就是针对不同的屏幕宽度使用不同的CSS样式，比如@media screen and （min-width：500px）{}，针对屏宽大于500px的设备使用特定样式。</p><p>于是只要我们在布局时使用rem，然后使用媒体查询定制不同屏幕宽度的htmlfont-size大小便可实现页面的响应式布局。但是在不支持媒体查询与rem的浏览器上无效....令一种思路是使用js精确计算html然后绑定onresize调用函数，但是页面性能受影响，对于不支持rem的浏览器无效</p><p>那么这就是响应式布局的全部了吗？I dont konw the more i learn the less i know</p>"
  },
  "项目总结之四个undefine":{
    "articletitle":"项目总结之四个undefine",
    "articlecontent":"<p>初次接触javascript时因为不了解js的作用机制常常会产生这样或那样的问题，最常见的一个问题当数据undefine了，这是初学js获取dom时最容易出现的问题，这种问题的出现情况大致分两种，一种是这段js代码是在dom元素生成之前便执行了，所以取不到喽。解决办法也分两种，一种是将js放在最底部，保证dom元素在js执行之前便生成完毕。令一种办法是将要执行的函数在window.onload中调用，同样也是为了保证元素生成在js执行之前。</p><p>第二种undefine出现的原因是没有区分dom元素与元素集合，例如document.querySelectorAll().addEventlistener()此时直接给元素集合绑定事件是无效的，正确的做法是使用for循环绑定或者使用事件代理利用父元素绑定。</p><p>还有一种undefine的情况则与js的异步机制有关，比如当我们使用ajax异步加载数据并把它赋值给一个变量时，我们在这个ajax的后面是无法获取到数据的，主要原因是ajax执行是需要时间的而且是异步的所以函数会继续往下执行，所以赋值语句永远在后面的代码之后执行，因此会出现undefine的情况。结局方案是将后面的代码放到ajax的回调函数赋值语句之后执行，或者将ajax改为同步。</p><p>最后一种undefine出现在动态生成dom元素，想象这样一种情况在页面上有一排卡片然后你用for循环为这些卡片绑定了事件，然后使用ajax又生成一系列卡片，然后你会发现绑定的事件对新生成卡片不起作用。原因在于新生成是在事件绑定之后执行的，解决方法将事件绑定放到最后执行最好的方法是使用事件代理。</p>"
  },
  "项目总结之写出清晰的逻辑":{
    "articletitle":"项目总结之写出清晰的逻辑",
    "articlecontent":"<p>当我们的项目中只有几十行上百行代码时我们几乎不会考虑怎样保证代码的逻辑性，似乎一切都是理所当然的。但是当代码量增长到近千行时我们如何保证代码逻辑的清晰性呢？套用圣经中的一句话“让数据的归数据，让视图的归视图”，最开始写代码时我们总是习惯与这样的逻辑，比如当我要实现一个下拉框然后ajax获取数据生成dom时我们总是倾向与写一个“大函数”，这个函数先实现下拉交互，然后ajax，最后生成dom。但这样理所当然的逻辑不可避免使的当代码量激增时带来的混乱</p><p>同样是上面那个功能正确的做法应该是将这个大函数分解成两个函数，一个只实现视图交互，一个实现数据请求并生成dom，只需要保证在视图交互函数的末尾调用数据请求函数即可。</p><p>所以大体上可以将js函数分成两类一类用来控制视图，一类用来请求数据，两者都只在乎对方的结果，唯一需要关心的是两者的执行顺序，总的来说要想实现逻辑的清晰就是要避免大函数分离小函数，注意执行顺序。</p>"
  },
   "项目总结之看穿angular的本质":{
    "articletitle":"项目总结之写出清晰的逻辑",
    "articlecontent":'<p>有人说前端是一个日新月异的领域，各种技术框架层出不穷。没错前端就是这么个职位了，不仅要求理性思维超强，还得感性思维爆表。以我的经验来看几乎所有认为前端简单的人都只是做着装配的工作而已，并且绝大部分是写后台Java转的前端，他们对前端没兴趣他们的眼里即便是查个简单的数据库也要比前端这些“奇技淫巧”更有技术含量，所以注定了他们浅尝辄止的学习习惯，拿来主义便成了理所当然的了。前端的难从来都不是技术上的，而是思想上的，前端的第一是准则是开放与自由。因为我不是科班出生所以不太擅长扯那么许多的专有名词，什么MVC，MVVM，OOP什么的，但是看穿事物本质的能力往往比这些名词更加珍贵。如果让我用一句话概括angularjs的话我会这么说“按照他的思维写代码，其他的交给他”，那么什么才是angular的思维，“不要管DOM，管好数据”。然后拆解一下angular其实最最主要的只有三个部分，指令，过滤器，服务，其他的一切包括内置指令了都可以由这三部分实现如果你愿意的话，指令的本质是什么？"是oop是对象"，它的scope管理着这个对象的属性及方法,react也是类似的思想，只不过它又进一步将scope分成了state及prop，然后这个指令的DOM状态是随着它的属性的变化而变化的,如果是双向绑定的话数据还能随DOM的变化而改变，angular已经把渲染的工作给包办了，你能说这样的编程方式比我完完全全用原生的更有难度吗？大概只有完全没写过原生的没见过世面不了解DOM才会这么想吧，过滤器的本质是什么?"过滤器本质就是一些带有输入返回值的函数"，只不过这些函数是需要“注册”的，注册的意思就是他们得被定义成$filter这个服务的方法，服务的本质是什么？服务的本质就是构造函数，依赖注入的本质是什么？依赖注入作为形参传入加服务（构造函数）的实例化。其实在学习angular的路上相当一部分人是被这些所谓的名词给吓到的，还有一部分人死于定势思维，但本质上还是基础不扎实。对于一个写了几年的jQuery的人，从来不敢不会原生js的人来说，angular无疑是一座大山，但对于一个习惯于快速转变思维，翻脸比翻书还快的前端工程师而言不过小菜一碟罢了。</p>'
   }
}
